한 문제에 하나의 알고리즘만 있는 것이 아니다.   
그렇다면 어떤 알고리즘이 더 좋을까?
=========
시간복잡도에 대해 알아보자.  
--------
**content**
1. [Time Complexity](#Time-Complexity)
2. [Big-O Notation](#Big-O-Notation)
***
### Time Complexity  
시간 복잡도(Time Complexity) : 수행 시간을 이론적으로 분석하기 위한 개념  

#### 시간복잡도를 사용하는 이유  
- 같은 알고리즘이라도 외부 요인 때문에 수행시간에 차이가 있다. (구현 언어, 컴퓨터 스팩 등)
- 이를 모두 계산할 수 없으므로 외부 요인을 고정했다고 가정.(= 추상화)
- 즉, 알고리즘만 비교하자.
  - 이 때,  알고리즘에 대한 "수행시간"에 대한 개념이 필요. -> 시간복잡도를 이용.


#### 시간복잡도 분석
코드에서 각 연산마다 걸리는 시간은 거의 동일하므로 시간복잡도는 실행되는 **연산의 개수(n)** 를 센다.  
하지만, if문, for문 등 상황마다 연산의 개수가 달라질 수 있으므로 수치를 근사화(단순화)하여 분석한다.  

1. Best-case Analysis : 가장 적은 시간
    - 연산 개수가 가장 적을 때를 구한다. 하지만 구한다고 해도 의미가 없는 값이다.
2. Worst-case Analysis : 가장 오랜 시간
    - 연산 개수가 가장 많을 때를 구한다. 수행시간의 상한을 구하는 것이기 때문에 의미가 있고, 주로 사용한다.
3. Average-case Analysis : 평균 시간
    - 연산의 평균을 구한다. 경우의 수가 많아 구하기 어렵다.

***
### Big-O Notation
시간복잡도를 표현할 땐 Big-O 표기법을 이용한다.  
그렇다면 Big-O 표기법은 무엇일까?  

Big-O 표기법은 두 함수간 관계를 나타내는 표기법으로 함수의 증가 속도를 비교한다.  
이 때, 증가 속도는 n이 무한대로 갈 때 어떤 함수가 더 빠르게 증가하는가를 의미한다.

이외에도 Big-Ω(오메가), Big-Θ(세타)가 있다.  

이 표기법들은 시간복잡도와 별개로 원래 존재했다. 즉, 시간복잡도 때문에 나온 표기법이 아니다.  

#### 3가지 표기법
1. Big-O : f(n) = O(g(n))일 때, f의 증가속도는 g보다 빠르지 않다. (비슷하거나 느리다.)  
<img src="/assets/images/Algorithm_BigO.PNG"> 를 만족해야 한다. 즉, 무한으로 발산하거나 양수로 수렴해야 한다.  

2. Big-Ω : f(n) = Ω(g(n))일 때, f의 증가속도는 g보다 느리지 않다. (비슷하거나 빠르다.)  
<img src="/assets/images/Algorithm_BigOmega.PNG"> 를 만족해야 한다. 즉, 무한으로 발산하거나 양수로 수렴해야 한다.  

3. Big-Θ : f(n) = Θ(g(n))일 때, f의 증가속도는 g와 비슷하다.  
f(n) = O(g(n))이고 f(n) = Ω(g(n))일 때.  
<img src="/assets/images/Algorithm_BigTheta.PNG"> 가 발산하지 않고 0이 아닌 양수로 수렴해야 한다.

#### 왜 Big-O를 사용할까?
많은 표기법이 있는데 왜 Big-O를 사용할까?

1. 시간복잡도를 계산할 때 가장 중요한 것은 최악의 경우이다.
2. 알고리즘의 최악의 경우를 정확히 계산하기 어렵고 복잡하다. 따라서 대략적으로 표기할 방법이 필요하다.
3. 추상적인 대상으로서 상수가 덜 중요하다.   

***
### 수행시간이 작은 알고리즘  
어떤 알고리즘이 수행시간이 적은 것인지 알아보자.  

[Big-O Complexity Chart](https://www.bigocheatsheet.com/)  
<img src="/assets/images/Algorithm_BigOChart.PNG">  

위 그래프는 Big-O 함수들을 비교한 것으로 완만할수록 좋다.   
즉, O(n)이 O(1)보다 s느리고 O(n long n)보다 빠른 것이다.  
