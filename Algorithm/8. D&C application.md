D&C에 대해 간단하게 공부해보았다. 이럴 어떻게 사용할까?  
========
D&C를 적용해보자.
-------
**contents**
1. [Multiplication](#Multiplication)
2. [Selection](#Selection)
***
### Multiplication
[Concept of Algorithm](https://github.com/ParkDH0809/TIL/blob/main/Algorithm/1.%20Concept%20of%20Algorithm.md)에서 
곱셈을 하는 방법이 Long, Lattice, Peasant Multiplication 등 다양하다는 것을 알았다.  

위 알고리듬들은 모두 시간복잡도가 O(n<sup>2</sup>)이다. 이보다 더 빠르게 실행할 수는 없을까?  

#### D&C를 적용한 Multiplication
곱셈에 D&C를 적용해보자.  
1234 \* 5678을 한다고 가정했을 때, 작은 문제로 만드는 가장 단순한 방법인 반으로 나누기를 해보자.  

<img src="/assets/images/Algorithm_DCmultiplication01.PNG">   
4자릿수를 2자릿수 2개로 나누었다.  

공식으로 나타내면 (12\*100 + 34) \* (56\*100 + 78) = (12\*56)\*10000 + (12\*78 + 34\*56)\*100 + (34\*78) 이다.   

이를 일반화하면 x = 10<sup>m</sup>a + b,  y = 10<sup>m</sup>c + d. (m은 자릿수의 반)   
**10<sup>2m</sup>ac + 10<sup>m</sup>(bc+ad) + bd** 를 계산하면 된다.  

pseudo code는 다음과 같다.
```
Multiplication(x, y, n) {
	if n = 1
		return x, y
	else
		m = n/2
		a = x/10^m
		b = x mod 10^m
		c = y/10^m
		d = y mod 10^m
		
		i = Multiplication(a, c, m)
		j = Multiplication(b, d, m)
		k = Multiplication(b, c, m)
		l = Multiplication(a, d, m)
		
		return 10^2m i + 10^m(k+l) + j
}
```

해당 알고리듬의 점화식 T(n)은 어떻게 될까?  

위 pseudo code를 보면 재귀를 4회 하며 인자값은 n/2가 된다.  
재귀를 사용하지 않는 부분에선 덧셈과 Shift연산을 하므로 O(n).  
점화식 **T(n) = 4T(n/2) + O(n)** 이다.  
<sup>10의 제곱은 0만 붙이면 되므로 곱셈이 아닌 Shift연산으로 하는 것이 유리하다.</sup>

Master Theorem을 이용하면 시간복잡도는 **O(n<sup>2</sup>)** 이다.  

D&C를 이용했음에도 시간복잡도가 빨라지지 않았다. 시간복잡도를 줄이기 위해선 재귀 횟수를 줄여야 한다는 것인데, 이를 어떻게 할 수 있을까?  

#### 좀 더 빠른 Multiplication  
재귀 횟수를 줄이려면 10<sup>2m</sup>ac + 10<sup>m</sup>(bc+ad) + bd 을 바꿔야 한다.  

10<sup>m</sup>(bc+ad)를 보자.  
bc+ad에 + (ac + bd) - (ac + bd)를 하면   
```
bc + ad = bc + ad + (ac + bd) - (ac + bd)
	= bc + ad + ac + bd - ac - bd  
	= ac + bd + (bc + ad - ac - bd)  
	= ac + bd + (a(d - c) + b(c - d))  
	= ac + bd + (a(d - c) - b(d - c))  
	= ac + bd + (a - b)(d - c)
```

bc + ad = ac + bd + (a - b)(d - c)이다.   

이 때, ac와 bd는 앞에서 구한 값이므로 (a - b)(d - c)만 계산하면 된다. 즉, 재귀가 1회 줄은 것이다.  

결과는 **10<sup>2m</sup>ac + 10<sup>m</sup>(ac + bd + (a - b)(d - c)) + bd** 이며 pseudo code는 다음과 같다.  
```
Multiplication(x, y, n) {
	if n = 1
		return x, y
	else
		m = n/2
		a = x/10^m
		b = x mod 10^m
		c = y/10^m
		d = y mod 10^m
		
		i = Multiplication(a, c, m)
		j = Multiplication(b, d, m)
		k = Multiplication(a-b, d-c, m)
		
		return 10^2m i + 10^m(i + j + k) + j
}
```

위 알고리즘에 대한 점화식 **T(n) = 3T(n/2) + O(n)** , 시간복잡도는 **O(n<sup>log<sub>2</sub>3</sup>)** 이다.  
시간복잡도를 O(n<sup>2</sup>)에서 O(n<sup>log<sub>2</sub>3</sup>)으로 줄이는 데에 성공했다.  

현재는 더욱 빠른 Multiplication 알고리듬이 존재한다고 한다. (harvey and van der hoeven algorithm : O(n log n))   

### Selection 
배열 A에서 값 k를 찾는 문제에 대해 D&C를 적용해보자.   

#### Binary Search 
배열이 정렬되어 있는 경우, 재귀를 이용해 값을 찾는 알고리듬이며 D&C로 설명이 가능하다.  
배열A의 중간값을 k와 비교한 후 탐색 범위를 반으로 줄이는 방식이다.  

아래 배열에서 찾고자 하는 k의 값이 1이라고 하자.  
|0|1|2|3|4|5|6|7|8|9|  
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|      

배열의 중간값을 k와 비교한다. 배열의 index 수가 짝수이므로 4, 5 중 아무것이나 선택해 비교하면 된다.  
5를 선택했다고 하자. 5>1이므로 탐색범위를 줄인다.  

|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|    

과정을 반복한다.  

pseudo code는 다음과 같다.  
```
int Binary Search(int A[], int k, int a, int b) {
	if(a > b) return -1;	//k와 같은 값이 없는 경우
	int mid = (a + b) / 2
	if(A[m] > k) return Binary Search(int A, k, a, m-1);
	else if(A[m] < k) return Binary Search(int A, k, m+1, b);
	else return mid; 	//k와 동일한 값을 찾은 경우
```

Binary Search는 재귀를 if문에 따라 1회 진행하고 인자 값이 반이 된다. 또, 재귀 외 연산이 c(상수)개 이므로  
위 알고리듬에 대한 점화식 **T(n) = T(n/2) + O(1)**. 시간복잡도는 **O(log n)** 이다.  

그렇다면 정렬이 되어있지 않는 경우는 어떨까?   

이 땐 정렬 후 Selection을 진행하면 된다.  
