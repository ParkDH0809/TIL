초기의 암호 알고리즘에 대해 알아보자.
================
**contents**
1. [Substitution Cipher](#Substitution-Cipher)
2. [Transposition Cipher](#Transposition-Cipher)
3. [One Time Pad](#One-Time-Pad)
4. [CodeBook](#CodeBook)
***
### Substitution Cipher
문자를 치환하는 암호 알고리즘이다.
#### 1. Shitf를 이용한 알고리즘
 
|a|b|c|d|e|...|x|y|z|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|B|C|D|E|F|...|Y|Z|A|    

위 표는 알파벳을 옆으로 1칸 shift했다. hello가 IFMMP로 되는 알고리즘이다.  
이 방식은 최대 shift할 수 있는 경우의 수가 26가지(알파벳 개수) 이므로 keyspace가 작다. 따라서 안전성이 낮다.  
- 취약점 : keyspace가 작다.
- 공격 방법 : 26가지 key를 대입한다.


#### 2. 무작위로 알파벳을 대입한 알고리즘

keyspace가 작다는 문제점을 해결할 수 있는 암호 알고리즘이다.

|a|b|c|d|e|...|x|y|z|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|Z|S|G|A|E|...|Q|H|J|    

무작위로 알파벳을 연결시키는 방식이다.  
이 경우는 keyspace가 26!이 되므로 shift를 이용한 알고리즘보다 안전성이 높다.(key를 하나씩 대입하기엔 시간이 매우 오래 걸린다.)  
하지만 이 알고리즘 또한 공격 방법이 있다.  

[알파벳 사용 빈도수](http://pi.math.cornell.edu/~mec/2003-2004/cryptography/subs/frequencies.html)  

<img src="/assets/images/Security_AlphabetFrequency.PNG" width="800" height="350">

영단어에서 알파벳이 사용되는 빈도수를 나타내는 그래프이다. 26가지 알파벳이 동일한 빈도로 사용되지 않는다는 것을 알 수 있다.   
이를 이용해 암호문을 푸는 것이다.

게다가 암호문에서 중복되는 알파벳 문자열에 the, it 등 자주 사용하는 단어를 대입하여 경우의 수를 더 줄일 수 있다.
- 취약점 : 치환한 알파벳이 등장하는 빈도수가 평문과 동일하다.
- 공격 방법 : 사용 빈도에 따라 알파벳 + 자주 사용하는 단어를 대입한다.


위의 문제점으로 결국 치환암호는 안전하다고 말할 수 없다는 결론에 이르게 된다.   
즉, 좋은 보안 system은 충분한 keyspace + 공격방법에 지름길이 없어야 한다.

***
### Transposition Cipher  
Substitution Cipher과 달리 알파벳을 전위하는 방식이다.  
#### 1. Double Transposition Cipher 
ex) helloworld
||col 1|col 2|
|:---:|:---:|:---:|
|row 1|h|e|
|row 2|l|l|
|row 3|o|w|
|row 4|o|r|
|row 5|l|d|  

위처럼 matrix를 만들고 행, 열의 순서를 바꾼다.

||col 2|col 1|
|:---:|:---:|:---:|
|row 5|d|l|
|row 3|w|o|
|row 1|e|h|
|row 2|l|l|
|row 4|r|o|

결과 : dlwoehllro  
Key는 matrix의 크기와 행, 열의 전위 순서이다. (5x2, (5,3,1,2,4), (2,1))  

Transposition Cipher은 plaintext와 ciphertext의 알파벳 빈도수가 같으므로 Substitution Cipher의 문제점을 해결할 수 있다.  
(빈도수를 이용한 공격 의미 X)  
하지만 결국 패턴이 존재하므로 이를 이용한 공격이 가능하다. (ex 어떤 간격으로 떨어져 있는가 ? )
- 취약점 : 패턴이 있다.
- 공격 방법 : 패턴을 파훼한다.  

***
### One Time Pad
안전성이 증명된 알고리즘 중 하나이다.  
<img src="/assets/images/Security_XORoperation.PNG">  
동일한 값이면 0, 아니면 1이 반환되는 특성을 가진 XOR을 이용한다.  

|letter|d|e|h|l|o|r|w|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|binary|000|001|010|011|100|101|110|

helloworld의 7개 알파벳에 대한 binary가 있을 때,

|h|e|l|l|o|w|o|r|l|d|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|010|001|011|011|100|110|100|101|011|000|  

로 적용이 가능하다. 여기에 key를 적용하면

||h|e|l|l|o|w|o|r|l|d|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|plaintext|010|001|011|011|100|110|100|101|011|000|  
|key|100|010|001|101|010|101|000|100|110|101|
|ciphertext|110|011|010|110|110|011|100|001|101|101|
||w|l|h|w|w|l|o|e|r|r|

XOR에 맞춰 ciphertext를 얻을 수 있다.  
이 때, key는 랜덤한 임의의 수이다.(plaintext의 길이에 맞게 만들어야 한다.)  

ciphertext와 key를 안전하게 받은 사람은 복호화를 진행하기 위해 ciphertext에 key를 XOR연산한다.

|ciphertext|110|011|010|110|110|011|100|001|101|101|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|key|100|010|001|101|010|101|000|100|110|101| 
|plaintext|010|001|011|011|100|110|100|101|011|000|
||h|e|l|l|o|w|o|r|l|d|  

같은 값끼리 연산하면 0이 되는 XOR의 특성을 이용해 복호화를 하는 것이다.  

이 방법이 안전한 이유는 key를 몰라서 하나씩 대입하면 plaintext가 아니지만 풀이가 되는 경우가 발생하기 때문이다.  
**즉, 다른 메세지가 된다는 것이다.**  
이 때, 사용한 key가 옳은 key인지 fake key인지 알 수 없다.
이 특성으로 One Time Pad의 안전성이 증명 되었다.  

하지만 One Time Pad 방식은 현실성이 떨어지는데, 그 이유는 받는 사람이 key를 알고있어야 하기 때문이다. 
plaintext를 안전하게 보내기 위한 key도 안전하게 보내야 하는 역설적인 상황이 발생한다.

***
### CodeBook
단어와 숫자가 매칭이 되는 책을 이용한다. (치환 암호의 일종이라고 할 수 있다.)
|word|number|
|:---:|:---:|
|hello|10578|
|world|54235|
|...|...|  

이 방법은 세계 1차 대전에서 실제로 사용되었다고 하는데, 사요한 CodeBook을 들켜서 암호 내용이 풀렸다고 한다.

***
위 algorithm들은 과거 이런게 있었으며 현대엔 사용하지 않는다.  
(현대의 기반이 되었다.)   
